#pragma once

#include "Scope.h"
#include <algorithm>

#ifdef SEMANT_FULL_VERBOSE
#include "utils/logger/Logger.h"
#endif // SEMANT_FULL_VERBOSE

#define SEMANT_RETURN_IF_FALSE_WITH_ERROR(cond, error, line_num, retval) \
    if (!(cond))                                                         \
    {                                                                    \
        _error_message = error;                                          \
        _error_line_number = line_num;                                   \
        return retval;                                                   \
    }

namespace semant
{
    struct ClassNode
    {
        std::shared_ptr<ast::Class> _class;
        std::vector<std::shared_ptr<ClassNode>> _children;
    };

    class Semant
    {
    private:
        // create error report from message, file name and line number
        std::string _error_message;
        std::string _error_file_name;
        int _error_line_number;

        // ----------------------------- Initialization -----------------------------
        // merge multiple programs were generated by parser to one program
        static std::shared_ptr<ast::Program> merge_to_one_program(const std::vector<std::shared_ptr<ast::Program>> &programs);
        std::shared_ptr<ast::Program> _program;    // program to analyze
        std::shared_ptr<ast::Type> _current_class; // current class of analysis for SELF_TYPE

        // ----------------------------- Analysis algorithms support -----------------------------
        std::unordered_map<std::string, std::shared_ptr<ClassNode>> _classes; // fast access to class info
        std::shared_ptr<ClassNode> _root;                                     // root of classes

        // ----------------------------- Class checking -----------------------------
        // creates dummy class with methods:
        // methods array: [ ("method1", [("", "ret_type1"), ("arg1, "type1"), ("arg2", "type2")]),
        //                  ("method2", [("", "ret_type2"), ("arg3, "type3"), ("arg4", "type4")]) ]
        std::shared_ptr<ClassNode> create_basic_class(const std::string &name,
                                                      const std::string &parent,
                                                      const std::vector<std::pair<std::string, std::vector<std::pair<std::string, std::string>>>> methods);

        // class check
        bool check_classes();
        bool check_class_hierarchy();
        bool check_main();
        // class check helpers
        bool check_class_hierarchy_for_cycle(const std::shared_ptr<ClassNode> &class_, std::unordered_map<std::string, int> &visited, const int &loop);
        static bool is_inherit_allowed(const std::shared_ptr<ast::Type> &class_);

        static const std::string _main_class;
        static const std::string _main_method;

        // ----------------------------- Expression checking -----------------------------
        // expressions type check
        bool check_expressions();
        bool check_expressions_in_class(const std::shared_ptr<ClassNode> &node, Scope &scope);
        bool check_expression_in_method(const std::shared_ptr<ast::Feature> &method, Scope &scope);
        bool check_expression_in_attribute(const std::shared_ptr<ast::Feature> &attr, Scope &scope);
        bool infer_expression_type(std::shared_ptr<ast::Expression> &expr, Scope &scope);

        std::shared_ptr<ast::Type> infer_new_type(const ast::NewExpression &new_);
        std::shared_ptr<ast::Type> infer_let_type(ast::LetExpression &let, Scope &scope);
        std::shared_ptr<ast::Type> infer_loop_type(ast::WhileExpression &loop, Scope &scope);
        std::shared_ptr<ast::Type> infer_unary_type(ast::UnaryExpression &unary, Scope &scope);
        std::shared_ptr<ast::Type> infer_binary_type(ast::BinaryExpression &binary, Scope &scope);
        std::shared_ptr<ast::Type> infer_assign_type(ast::AssignExpression &assign, Scope &scope);
        std::shared_ptr<ast::Type> infer_if_type(ast::IfExpression &if_, Scope &scope);
        std::shared_ptr<ast::Type> infer_sequence_type(ast::ListExpression &seq, Scope &scope);
        std::shared_ptr<ast::Type> infer_cases_type(ast::CaseExpression &cases, Scope &scope);
        std::shared_ptr<ast::Type> infer_dispatch_type(ast::DispatchExpression &disp, Scope &scope);
        std::shared_ptr<ast::Type> infer_object_type(ast::ObjectExpression &obj, Scope &scope);

        // ----------------------------- Type checking support -----------------------------
        // basic types
        static std::shared_ptr<ast::Type> _bool;
        static std::shared_ptr<ast::Type> _object;
        static std::shared_ptr<ast::Type> _int;
        static std::shared_ptr<ast::Type> _string;
        static std::shared_ptr<ast::Type> _io;
        static std::shared_ptr<ast::Type> _object_parent; // parent of class Object for algorithms
        static std::shared_ptr<ast::Type> _self_type;

        // expressions type check helpers

        // t1 is subtype of t2
        // this function is not —Åommutative !!!
        bool check_types_meet(const std::shared_ptr<ast::Type> &dynamic_type, const std::shared_ptr<ast::Type> &static_type) const;
        inline static bool same_type(const std::shared_ptr<ast::Type> &t1, const std::shared_ptr<ast::Type> &t2) { return t1->_string == t2->_string; }

        std::shared_ptr<ast::Type> exact_type(const std::shared_ptr<ast::Type> &type) const;
        std::shared_ptr<ast::Type> find_common_ancestor(const std::vector<std::shared_ptr<ast::Type>> &classes) const;
        std::shared_ptr<ast::Type> find_common_ancestor_of_two(const std::shared_ptr<ast::Type> &t1, const std::shared_ptr<ast::Type> &t2) const;
        std::shared_ptr<ast::Feature> find_method(const std::string &name, const std::shared_ptr<ast::Type> &class_, const bool &exact) const;
        inline bool check_exists(const std::shared_ptr<ast::Type> &type) const { return _classes.find(type->_string) != _classes.end(); }

        SEMANT_FULL_VERBOSE_ONLY(Logger _logger;);

    public:
        // get vector of programs that were generated by parser
        explicit Semant(std::vector<std::shared_ptr<ast::Program>> programs);

        // return root of class hierarhy program that consists of classes from all programs
        std::pair<std::shared_ptr<ClassNode>, std::shared_ptr<ast::Program>> infer_types_and_check();

        // determine basic types
        static bool is_not_basic_class(const std::shared_ptr<ast::Type> &class_);
        static bool is_trivial_type(const std::shared_ptr<ast::Type> &class_);
        inline static bool is_bool(const std::shared_ptr<ast::Type> &t) { return same_type(t, _bool); }
        inline static bool is_int(const std::shared_ptr<ast::Type> &t) { return same_type(t, _int); }
        inline static bool is_string(const std::shared_ptr<ast::Type> &t) { return same_type(t, _string); }
        inline static bool is_self_type(const std::shared_ptr<ast::Type> &t) { return same_type(t, _self_type); }

        // get basic types
        inline static std::shared_ptr<ast::Type> int_type() { return _int; }
        inline static std::shared_ptr<ast::Type> bool_type() { return _bool; }
        inline static std::shared_ptr<ast::Type> string_type() { return _string; }
        inline static std::shared_ptr<ast::Type> self_type() { return _self_type; }

        // return class_ if type is SELF_TYPE or type
        static std::shared_ptr<ast::Type> exact_type(const std::shared_ptr<ast::Type> &type, const std::shared_ptr<ast::Type> &class_);

        std::string get_error_msg() const;
    };
}