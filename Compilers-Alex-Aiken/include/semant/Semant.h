#pragma once

#include "ast/AST.h"
#include <unordered_map>
#include <algorithm>

#ifdef SEMANT_FULL_VERBOSE
#include <cassert>
#include <iostream>
#endif // SEMANT_FULL_VERBOSE

#define SEMANT_RETURN_IF_FALSE_WITH_ERROR(cond, error, line_num, retval) \
    if (!(cond))                                                         \
    {                                                                    \
        _error_message = error;                                          \
        _error_line_number = line_num;                                   \
        return retval;                                                   \
    }

#define SEMANT_RETURN_IF_FALSE(cond, retval) \
    if (!(cond))                             \
    {                                        \
        return retval;                       \
    }

namespace semant
{
    class Scope
    {
    private:
        std::vector<std::unordered_map<std::string, std::shared_ptr<ast::Type>>> _symbols; // vectors of maps for convenient way to model class scopes

    public:
        static const std::string _self; // cannot be names of symbols

        enum ADD_RESULT
        {
            OK,
            RESERVED,
            REDEFINED
        };

        inline void push_scope() { _symbols.emplace_back(); }
        inline void pop_scope() { _symbols.pop_back(); }

        ADD_RESULT add_if_can(const std::string &name, const std::shared_ptr<ast::Type> &type);
        void add(const std::string &name, const std::shared_ptr<ast::Type> &type) { _symbols.back()[name] = type; }

        std::shared_ptr<ast::Type> find(const std::string &name, const int &scope_shift = 0) const;

#ifdef SEMANT_FULL_VERBOSE
        void dump() const;
#endif // SEMANT_FULL_VERBOSE
    };

    class Semant
    {
    private:
        struct ClassNode
        {
            std::shared_ptr<ast::Class> _class;
            std::vector<std::shared_ptr<ClassNode>> _children;
        };

        // create error report from message, file name and line number
        std::string _error_message;
        std::string _error_file_name;
        int _error_line_number;

        // ----------------------------- Initialization -----------------------------
        // merge multiple programs were generated by parser to one program
        static std::shared_ptr<ast::Program> merge_to_one_program(const std::vector<std::shared_ptr<ast::Program>> &programs);
        std::shared_ptr<ast::Program> _program;    // program to analyze
        std::shared_ptr<ast::Type> _current_class; // current class of analysis for SELF_TYPE

        // ----------------------------- Analysis algorithms support -----------------------------
        std::unordered_map<std::string, std::shared_ptr<ClassNode>> _classes; // fast access to class info
        std::shared_ptr<ClassNode> _root;                                     // root of classes

        // ----------------------------- Class checking -----------------------------
        // creates dummy class with methods:
        // methods array: [ ("method1", [("", "ret_type1"), ("arg1, "type1"), ("arg2", "type2")]),
        //                  ("method2", [("", "ret_type2"), ("arg3, "type3"), ("arg4", "type4")]) ]
        std::shared_ptr<ClassNode> create_basic_class(const std::string &name,
                                                      const std::string &parent,
                                                      const std::vector<std::pair<std::string, std::vector<std::pair<std::string, std::string>>>> methods);

        // class check
        bool check_classes();
        bool check_class_hierarchy();
        bool check_main();
        // class check helpers
        bool check_class_hierarchy_for_cycle(const std::shared_ptr<ClassNode> &class_, std::unordered_map<std::string, int> &visited, const int &loop);
        static bool is_not_basic_class(const std::shared_ptr<ast::Type> &class_);
        static bool is_inherit_allowed(const std::shared_ptr<ast::Type> &class_);

        static const std::string _main_class;
        static const std::string _main_method;

        // ----------------------------- Expression checking -----------------------------
        // expressions type check
        bool check_expressions();
        bool check_expressions_in_class(const std::shared_ptr<ClassNode> &node, Scope &scope);
        bool check_expression_in_method(const std::shared_ptr<ast::Feature> &method, Scope &scope);
        bool check_expression_in_attribute(const std::shared_ptr<ast::Feature> &attr, Scope &scope);
        bool infer_expression_type(std::shared_ptr<ast::Expression> &expr, Scope &scope);

        std::shared_ptr<ast::Type> infer_new_type(const ast::NewExpression &new_);
        std::shared_ptr<ast::Type> infer_let_type(ast::LetExpression &let, Scope &scope);
        std::shared_ptr<ast::Type> infer_loop_type(ast::WhileExpression &loop, Scope &scope);
        std::shared_ptr<ast::Type> infer_unary_type(ast::UnaryExpression &unary, Scope &scope);
        std::shared_ptr<ast::Type> infer_binary_type(ast::BinaryExpression &binary, Scope &scope);
        std::shared_ptr<ast::Type> infer_assign_type(ast::AssignExpression &assign, Scope &scope);
        std::shared_ptr<ast::Type> infer_if_type(ast::IfExpression &if_, Scope &scope);
        std::shared_ptr<ast::Type> infer_sequence_type(ast::ListExpression &seq, Scope &scope);
        std::shared_ptr<ast::Type> infer_cases_type(ast::CaseExpression &cases, Scope &scope);
        std::shared_ptr<ast::Type> infer_dispatch_type(ast::DispatchExpression &disp, Scope &scope);
        std::shared_ptr<ast::Type> infer_object_type(ast::ObjectExpression &obj, Scope &scope);

        // ----------------------------- Type checking support -----------------------------
        // basic types
        static std::shared_ptr<ast::Type> _bool;
        static std::shared_ptr<ast::Type> _object;
        static std::shared_ptr<ast::Type> _int;
        static std::shared_ptr<ast::Type> _string;
        static std::shared_ptr<ast::Type> _io;
        static std::shared_ptr<ast::Type> _object_parent; // parent of class Object for algorithms
        static std::shared_ptr<ast::Type> _self_type;

        // expressions type check helpers

        // t1 is subtype of t2
        // this function is not —Åommutative !!!
        bool check_types_meet(const std::shared_ptr<ast::Type> &dynamic_type, const std::shared_ptr<ast::Type> &static_type) const;
        inline static bool same_type(const std::shared_ptr<ast::Type> &t1, const std::shared_ptr<ast::Type> &t2) { return t1->_string == t2->_string; }
        inline static bool is_bool(const std::shared_ptr<ast::Type> &t) { return same_type(t, _bool); }
        inline static bool is_int(const std::shared_ptr<ast::Type> &t) { return same_type(t, _int); }
        inline static bool is_string(const std::shared_ptr<ast::Type> &t) { return same_type(t, _string); }

        std::shared_ptr<ast::Type> exact_type(const std::shared_ptr<ast::Type> &type) const;
        std::shared_ptr<ast::Type> find_common_ancestor(const std::vector<std::shared_ptr<ast::Type>> &classes) const;
        std::shared_ptr<ast::Type> find_common_ancestor_of_two(const std::shared_ptr<ast::Type> &t1, const std::shared_ptr<ast::Type> &t2) const;
        std::shared_ptr<ast::Feature> find_method(const std::string &name, const std::shared_ptr<ast::Type> &class_, const bool &exact) const;
        inline bool check_exists(const std::shared_ptr<ast::Type> &type) const { return _classes.find(type->_string) != _classes.end(); }

        // for debug
#ifdef SEMANT_FULL_VERBOSE
        int _level = 0;

        void log(const std::string &msg) const;
        void log_enter(const std::string &msg);
        void log_exit(const std::string &msg);
#endif // SEMANT_FULL_VERBOSE

    public:
        // get vector of programs that were generated by parser
        explicit Semant(std::vector<std::shared_ptr<ast::Program>> &programs);

        // return one program that consists of classes from all programs
        std::shared_ptr<ast::Program> infer_types_and_check();

        std::string get_error_msg() const;
    };
}